## 引用和const

> 该篇只讲引用，是因为这确实是一个比较复杂的东西。

#### 主要知识点

1. 引用的概念

2. 引用传递和值传递

3. 引用的作用

4. const修饰符

5. 浅拷贝和深拷贝

#### 1.引用的概念
&emsp;&emsp;`C++`的**指针**使得我们可以直接和内存进行交互。然而，有时候我们仅仅需要一个*传递一个变量*，而不关注其他的内容。所以`C++`设计了引用，从而减少了`&`和`*`的操作。
<br/>&emsp;&emsp;**引用**是一种已经包装过的**常指针**，其很多特性和常指针很像，然而其不需要复杂的`&`和`*`操作。**引用**可以形象化地理解为给变量取别名。当**引用**传递给参数时，可以理解为把整个**变量**给了函数。
<br/>&emsp;&emsp;因为**引用**本质上是一个**常指针**，因而 1)不能用一个**常量**来给引用赋值。 2)引用定义时就要初始化，且引用的变量在中途不能更改。

#### 2.引用传递和值传递

&emsp;&emsp;无论是*普通基类对象*还是*指针*，当函数调用或者返回的时候都属于**值传递**的方式，当参数是类对象时，其会调用拷贝构造函数来生成一个副本，作为函数内的临时对象。而指针是通过*拷贝地址*的方式来间接实现*传递变量*的。
<br/>&emsp;&emsp;而引用虽然本质上是**常指针**，但是从形式上来说其确实*传递了变量*，因而当一个参数为**引用**时，其参数必须是可修改的左值。例如参考以下代码，其输出将为10。

```cpp
void add(int& a)
{
    a = a + 10;
}

int main()
{
    int a = 0;
    add(a);
    cout << a << endl;
    return 0;
}
```

#### 3.引用的作用

&emsp;&emsp;**引用**就其功能来说完全可以通过指针来实现，但是**引用**是的*传递参数*更加地方便，也提高了程序的阅读能力。其中`cin >>`便是一个很好地使用了**引用**的例子，因为流输入是个*变量*赋值的。
<br/>&emsp;&emsp;其调用参数和使用参数的时候和普通的对象几乎没有什么区别，所以也提高了代码的可维护性，引用在必要的地方还可以节省一次*创建拷贝*的过程，节省了内存空间。

#### 4.const修饰符

&emsp;&emsp;`const`表明了**常**的属性，所以要理解`const`，就需要理解**常**这个概念。`const`可以修饰变量，指针，函数和成员/字段，我们将`非const`赋给一个`const`对象，但是反过来就不可以。

- 修饰变量

&emsp;&emsp;这里的变量不包括指针，既可以是基类型，也可以是类对象。当然，当一个变量用`const`来修饰时，表明其**成员**无法修改，对于类对象来说，其还有不能调用`非const`函数的特征(因为`const`函数可以保证其数据成员不修改)。
<br/>&emsp;&emsp;除此之外，通过`#define`也可以实现类似的功能，但是其原理是通过文本替换来实现的。

> 虽然其**成员**无法修改，但是如果其成员中有一个*指针*，则其指针指向不能变，但仍然可以通过*指针*来修改内存中的数据。

- 修饰函数

&emsp;&emsp;当一个函数声明为`const`时，其表示这个一个不会修改**数据成员**的函数，任何企图修改数据成员的函数都会编译不通过。这样可以确保`const`对象调用的方法不会修改成员。

- 修饰指针

&emsp;&emsp;指针有两处地方可以修饰，一种是**基类型**前，另一种是**变量前**，其区别如下
<br/>&emsp;&emsp;`const int *p`表示指向`const`数据的指针。其指针的指向可以修改，但是*不能通过该指针修改其内存中的值*(并没有要求其指向的是一个常量)
<br/>&emsp;&emsp;而`int * const p`是一个常指针，其指向不能更改，但是*可以通过该指针修改内存中的值*。
<br/>&emsp;&emsp;`const`设计出来主要用来 1)定义一个全局的变量 2)防止传递参数时函数内部修改变量的值。

#### 6.浅拷贝和深拷贝

&emsp;&emsp;对于一般的类型来说，编译器默认的拷贝就是**深拷贝**。然而当类型包含**指针**类型的数据时，系统默认会拷贝**指针的值**，而不会去拷贝其内存中的值。这种通过拷贝后数据仍然是**一份**(占用同一块)内存空间的现象就叫做**浅拷贝**。浅拷贝可以减少变量所占的空间(因为需要拷贝的数据少了)，但是会导致很多问题。
<br/>&emsp;&emsp;而问题主要出析构函数这一块，析构函数希望通过*撤销动态空间来防止内存泄露*，但是这样做会出现*野指针*的现象。
<br/>&emsp;&emsp;后续，我会通过例子来讲解**浅拷贝**和**深拷贝**的实际作用。

> Author:cht.
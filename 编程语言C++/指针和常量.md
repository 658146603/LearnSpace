## 指针和常量

> [回到上级](./index.md)

> 这篇分享主要是讲容易忽略的东西，不是关于实践的，意思是说，看一看有好处，但是基本上没用（出现问题查一查网络就可以解决了）。

#### 主要知识点

1. 关于指针和类型

2. 指针的位移运算符

3. [不要求掌握]奇怪的"类型"-数组

4. [难点]二级指针和指向数组的指针

5. 常量初始化的问题

6. 引用-一种特殊的常指针

#### 1.关于指针和类型

**指针**是一种C/C++变量，其存储的信息是*变量的地址*和*变量的类型信息*，而变量地址是所有变量都具有的属性，表明其在内存中的位置。每种类型，包括自定义类型，系统都会自动派生出对应的指针类型，其定义只要在参数前加上*就可以了。

在这里，我们需要注意以下几点：

- 变量地址指该变量所占内存空间的首地址。例如`int a`占了地址105-108，则`a`的地址为105.

- 当该变量为自定义类型时，其所占的空间为其成员所占的空间和，**不包含动态申请的空间**(实际上，所占内存空间只和**类型信息**有关系)。例如有以下类型。则其所占的空间为12Bytes(假设一个指针占4Bytes).

```cpp
class A
{
    string* a;
    int* b;
    long long* c;
};
```

- 虽然**指针**是跟着类型的，但实际上定义变量时指针有一种修饰变量的感觉，数组也是同理，例如以下定义的代码。

- 学了运算符重载后，我们知道，&和*是可以重载的，这个可以实现特殊的功能，但是现在用不到，所以我懒得讲。

```cpp
int a,*b,c[5];
```

- 可以用`sizeof()`(括号中参数为变量或者类型，其实跟常量或者表达式都是可以的，总之，他需要**类型信息**)，其返回值为**该类型**所占空间（以字节计）

指针为了配合变量，C++语言准备了取地址操作符&和解指针操作符*，其作用很简单，在这里就不说了。

#### 2.指针位移运算符

下面讲一讲常常忽略的指针位移运算符，取名*位移*是因为形象。下面是主要的运算操作符（还是结合实际例子讲）。

```cpp
#include<iostream>
using namespace std;
int main()
{
    int a[2] = {1,3};
    int *p = a; //定义一个指针变量p，其指向数组的第0个元素，就假设其地址值为101(当然，实际上是16进制的).
    cout << p << endl; //输出101.
    p = p + 1; //p后移以为，指向数组的第1个元素.
    cout << p << endl; //输出105(假设int占4Bytes).
    cout << *p << endl; //输出3.
    return 0;
}
```

> 推荐代码都跑一下看看效果。

发现上面的代码中有`p = p + 1`这个语句，但是`p`是`int*`型的，`1`是`int`型的，为了表示*位移*，指针的地址值并没有"加1"，而是往下移了一位，这样是为了方便。

> 如果你看懂的话，请解释`sort(a,a+8)`中`a+8`的含义。

除了有`T* + int -> T*`外，还有`T* - T* -> int`，相信你也肯定能够猜到相减有什么含义。

#### 3.奇怪的"类型"-数组

> 其实本来我想先讲4再讲3，但既然提到了数组，那就讲讲数组这个奇怪的东西。

其实我想说，这个**数组**并不是一个真正的类型。而是一个不完全类型（我也不知道这是什么东西）。所以，它会发生很奇怪的现象。

请看下面代码。

```cpp
#include<iostream>
using namespace std;
int main()
{
    int a[5] = {1,2,3,4,5};
    cout << sizeof(a) << endl;
    sizetest();

    return 0;
}

void sizetest(int a[]) //请看这个，入参其实和int *a没什么两样。
{
    cout << sizeof(a) << endl;
}
```

你会发现，打出来的两行东西是不一样的，第一行是`20`，第二行是`4`，所以*数组*在传递参数的时候丢失了**信息**，这也是在C++中，传递数组时也需要跟着传递数组长度的原因。

究其原因，实际上还是两者类型不同，而恰好数组是不能直接当作参数传递的（如果要传递参数，其一定会转化为指针），但是数组的下标操作和指针是一致的，所以我们应该认识到，数组和指针是不一样的，其也是一种**类型**，这是为下面介绍二级指针和指向数组的指针做铺垫的。

#### 4.二级指针和指向数组的指针

请看下列代码

```cpp
#include<iostream>
using namespace std;
int main()
{
    int a[4][10];

    int **pa = a; //int(*)[10]类型的值不能初始化int**的实体
    int (*pa)[10] = a; //通过
}
```

第一个就是二级指针，第二个就是指向数组的指针，这个很少用，真的很少用，当然，请注意`int (*pa)[10]`和`int *pa[10]`的区别，一个是指向数组的指针，一个是基类型为`int*`的一个数组。

#### 5.常量初始化的问题

常量必须在定义时初始化，如果是一个类，则需要在参数初始化表中进行初始化，在其他地方是不行的，以下为两个正确的代码。

```cpp
#include<iostream>
using namespace std;
int main()
{
    const int a = 0;
    return 0;
}
```

```cpp
#include<iostream>
using namespace std;

class Ex
{
public:
    Ex(int b):a(b){ }
private:
    const int a;
};

```

当然，还有比较两种特殊的**常量**，常指针和引用，所以引用的初始化也是一样的。

#### 6.引用-一种特殊的常指针

可以这么说，引用是一种特殊的常指针，只是简化了参数传递的语法，让程序更加简洁易懂而设计的，因为它本质上是常指针，所以其一旦引用的目标确定，就无法再更改了。

如果要说引用的话，会涉及到**浅拷贝和深拷贝**，**值传递和引用传递**等概念，这个在下一篇会详细介绍。

> 参与编写人员:cht
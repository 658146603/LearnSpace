## 指针和数组

> [回到上级](./index.md)

> 这篇来自于`指针和常量`这一篇，主要是想按照一个个知识点来讲。

#### 主要知识点

1. 指针和类型信息

2. 指针的`+`和`-`运算符

3. 指针的下标运算

4. 奇怪的"类型"-数组

5. 二级指针和指向数组的指针

#### 1.指针和类型信息

&emsp;&emsp;**指针**是一种C/C++变量，其存储的信息是*变量的地址*和*变量的类型信息*。每种类型，包括自定义类型，系统都会自动派生出对应的**指针类型**(在变量前加*)，其定义只要在参数前加上*就可以了。
<br/>&emsp;&emsp;在这里，我们需要注意以下几点：

- 变量地址指该变量所占内存空间的首地址。例如`int a`占了内存105-108，则`a`的地址为105.

- 当该变量为自定义类型时，其所占的空间为其成员所占的空间和，**不包含动态申请的空间**，一个特定的类具有唯一确定的空间大小(不包括动态申请的内存空间)。例如有以下类型。则其所占的空间为12Bytes(假设一个指针占4Bytes)，获取一个变量或者类型占用的内存空间可以用`sizeof()`。

```cpp
class A
{
    string* a;
    int* b;
    long long* c;
};
```
- 类和对应的指针的`&`和`*`运算符默认为取地址和解指针运算符，当然也可以根据实际需要来重载。

#### 2.指针的`+`和`-`运算符

&emsp;&emsp;下面讲一讲常常忽略的指针的`+`和`-`运算符，下面是主要的运算操作符（还是结合实际例子讲）。

```cpp
#include<iostream>
using namespace std;
int main()
{
    int a[2] = {1,3};
    int *p = a; //定义一个指针变量p，其指向数组的第0个元素，就假设其地址值为101(当然，实际上是16进制的).
    cout << p << endl; //输出101.
    p = p + 1; //p后移以为，指向数组的第1个元素.
    cout << p << endl; //输出105(假设int占4Bytes).
    cout << *p << endl; //输出3.
    return 0;
}
```

> 推荐代码都跑一下看看效果。

&emsp;&emsp;`int*(a) + int(b)`表示指针的地址向后移动`b * sizeof(int)`位，也就是b个`int`型的长度，这样做是为了方便数组和移位的操作。
<br/>&emsp;&emsp;当然`int*(a) - int*(b)`和上面类似，表示中间相差的元素个数。

#### 3.指针的下标运算

&emsp;&emsp;指针的下标运算和数组的很像，实际上下标运算通常在动态数组中应用，例如`a[2]`表示动态数组`a`的第二个元素。根据上文的运算法则，`a[2]<==>*(a+2)`，其两者实现的效果等价。

#### 5.奇怪的"类型"-数组

> 其实本来我想先讲4再讲3，但既然提到了数组，那就讲讲数组这个奇怪的东西。

&emsp;&emsp;**数组**并不是一个真正的类型。而是一个不完全类型，静态数组的**容量大小**只能在编译前确定，而且它还具有很多奇怪的性质。
<br/>&emsp;&emsp;**数组**是用一块连续的内存空间来存储的，因此，C++的数组可以通过数组名来获取其首地址，用下标运算获取对应的元素。
<br/>&emsp;&emsp;请看下面代码。

```cpp
#include<iostream>
using namespace std;
int main()
{
    int a[5] = {1,2,3,4,5};
    cout << sizeof(a) << endl;
    sizetest();

    return 0;
}

void sizetest(int a[]) //请看这个，入参其实和int *a没什么两样。
{
    cout << sizeof(a) << endl;
}
```
&emsp;&emsp;你会发现，打出来的两行东西是不一样的，第一行是`20`，第二行是`4`。这是因为前一个`sizeof()`可以通过上下文定位数组（也就获取到了它元素的个数），而函数中的`sizeof()`无法获取数组的长度信息(因为已经是一个指针了)，也就是说，数组只能通过**指针**的方式传递，且会丢失信息。

#### 6.二级指针和指向数组的指针

> 二级指针包括指针的指针，也包括指向数组的指针。当然，这里的二级指针的含义指指向指针的指针。

请看下列代码

```cpp
#include<iostream>
using namespace std;
int main()
{
    int a[4][10];

    int **pa = a; //int(*)[10]类型的值不能初始化int**的实体
    int (*pa)[10] = a; //通过
}
```

&emsp;&emsp;第一个就是二级指针，第二个就是指向数组的指针，这个很少用，真的很少用，当然，请注意`int (*pa)[10]`和`int *pa[10]`的区别，一个是指向数组的指针，一个是基类型为`int*`的一个数组。

> Author:cht.